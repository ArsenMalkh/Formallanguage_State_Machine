ID 13: Малхасян Арсен
# Алгоритм:
Сначала из обратной польской записи через функцию Create(), получим регулярное выражение, и функция проверяет если элемент строки число или буква, то просто добавить в первый стек(стек регулярного выражения), и еще в другой стек (substr_sets  двумерный стек сетов в котором мы каждый раз добавляем индексы подстрока, то есть элемента).  Потом если мы встречаем “+”, то просто, правый и левый часть плюса положим в одну ячейку стека substr_sets .(значит, обедняем все индексы подстрок). Потом если мы встречаем “.”, тогда просто достаем и проверяем две последние ячейки (если конец первой подстроки начало второго) положим в одну ячейку substr_sets. И в конце если встречаем “*”, то (во первых могут быть варианты, эпсилон, тогда добавим в последнем ячейке стека нулевые подстроки все) и делаем тоже самые действия как и в “.”, только много,  до конца, пока можно. Логично получается мы в стеке substr_sets все подстроки “u”, которые можно получить. В конце выбираем самый длинный и выводим длину.
# Сложность
Среднее время	 - O(n*m^4)  n – длина регулярного выражения в О.П.З.  m – длина “u”.

